<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">    
    <meta http-equiv="Content-Security-Policy"
        content="default-src *;img-src * 'self' data: https: filesystem: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' *; style-src  'self' 'unsafe-inline' *">

    <title>Artifact Colors Editor</title>
    <style>
        #buttonRow {
            width: 160px;
        }
        #currentColourBox {
            display: flex;
            justify-content: center; /* Centers horizontally */
            align-items: center;
            width: 160px;
            height: 80px;
            overflow: hidden;
            border: 1px solid black;
            box-sizing: border-box;
        }
        #currentColour {
            background: black;
            border-radius: 200px;
            flex-shrink: 0;
        }
        .colourButton {
            width: 20px;
            height: 20px;
            padding: 0;
        }
        canvas {
            image-rendering: pixelated;
            zoom: 4;
        }
    </style>
</head>

<body>  
    <input type="file" id="fileInput" accept="image/png">
    <div>
        <canvas id="original"> </canvas>
        <canvas id="bw"> </canvas>
        <canvas id="artifact" style="display: none;"> </canvas>
        <canvas id="blur"> </canvas>
    </div>
    <div id="buttonRow"> </div>
    <div id="currentColourBox">
        <div id="currentColour"> </div>
    </div>
    <div>
        <label for="range">Brush Size:</label>
        <input type="range" id="radius" name="radius" min="0" max="100" value="3">
        <span id="radius-value">50</span>
    </div>

    <script>
        let width;
        let height;

        document.getElementById("fileInput").addEventListener("change", handleFile);

        function colours() {
            const colours = [];
            for (let w = 0; w < 64; w++) {
                const r = w & 1;
                const g = w >>> 1 & 1;
                const b = w >>> 2 & 1;
                const c = w >>> 3 & 1;
                const m = w >>> 4 & 1;
                const y = w >>> 5 & 1;
                const colour = [
                    127 * r + 64 * m + 64 * y,
                    127 * g + 64 * c + 64 * y,
                    127 * b + 64 * c + 64 * m
                ];
                const hsl = rgbToHsl(colour[0], colour[1], colour[2]);
                colours.push({
                    r: r,
                    g: g,
                    b: b,
                    c: c,
                    m: m,
                    y: y,
                    colour: colour,
                    h: hsl.h,
                    s: hsl.s,
                    l: hsl.l 
                });
            }
            return colours;
        }

        const referenceColours = colours();

        function hex(value) {
            return value.toString(16).padStart(2, '0');
        }

        function createButtons() {
            const buttonRow = document.getElementById("buttonRow");
            for (let i = 0; i < 64; i++) {
                const colour = referenceColours[i];
                const button = document.createElement('button');
                button.className = 'colourButton';
                button.type = 'button';
                button.setAttribute('i', i);
                const background = `#${hex(colour.colour[0])}${hex(colour.colour[1])}${hex(colour.colour[2])}`;
                button.style.background = background;
                button.onclick = onButtonClick;
                buttonRow.appendChild(button);
            }
        }
        
        let currentColour = referenceColours[0];
        let brushRadius = 3;

        function setPreviewRadius() {
            const slider = document.getElementById("radius");
            const output = document.getElementById("radius-value");
            brushRadius = parseInt(slider.value);
            output.innerHTML = brushRadius + 1;
            const div = document.getElementById("currentColour");
            div.style.width = `${brushRadius * 2 + 1}px`;
            div.style.height = `${brushRadius * 2 + 1}px`;
        }

        document.getElementById("radius").oninput = setPreviewRadius;
        setPreviewRadius();

        function onButtonClick(event) {
            const button = event.target;
            const i = parseInt(button.getAttribute('i'));
            currentColour = referenceColours[i];
            var div = document.getElementById("currentColour");
            const background = `#${hex(currentColour.colour[0])}${hex(currentColour.colour[1])}${hex(currentColour.colour[2])}`;
            div.style.background = background;
            
            var box = document.getElementById("currentColourBox");
            box.style.background = currentColour.l >= 50 ? "black" : "white";
        }

        let startX;
        let startY;
        function onCanvasDown(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            startX = Math.floor((event.clientX - rect.left) / canvas.currentCSSZoom);
            startY = Math.floor((event.clientY - rect.top) / canvas.currentCSSZoom);
        }
        
        function onCanvasUp(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const endX = Math.floor((event.clientX - rect.left) / canvas.currentCSSZoom);
            const endY = Math.floor((event.clientY - rect.top) / canvas.currentCSSZoom);

            const v = [
                [currentColour.r, currentColour.g, currentColour.b],
                [currentColour.c, currentColour.m, currentColour.y],
            ];

            const radiusSquared = brushRadius * brushRadius;

            // if len is 0, we draw at 1 pixel
            const len = Math.max(Math.abs(endX - startX), Math.abs(endY - startY)) || 1;
            for (let i = 0; i <= len; i++) {
                const x = Math.round(startX + i * (endX - startX) / len);
                const y = Math.round(startY + i * (endY - startY) / len);
                for (let y2 = -brushRadius; y2 <= brushRadius; y2++) {
                    const y1 = y + y2;
                    if (y1 < 0 || y1 >= monoBuffer.length) continue;
                    const rowPhase = y1 % 2;
                    for (let x2 = -brushRadius; x2 <= brushRadius; x2++) {
                        if (x2 * x2 + y2 * y2 > radiusSquared) continue;
                        const x1 = x + x2;
                        if (x1 < 0 || x1 >= monoBuffer[0].length) continue;
                        const phase = x1 % 3;
                        monoBuffer[y1][x1] = v[rowPhase][phase];
                        alphaBuffer[y1][x1] = 1;
                    }
                }
            }
            
            renderBw();
            renderArtifactColors();
        }

        function setCanvasHandlers(id) {
            const canvas = document.getElementById(id);
            canvas.onmousedown = onCanvasDown;
            canvas.onmouseup = onCanvasUp;
        }

        createButtons();

        const monoBuffer = [];
        const alphaBuffer = [];

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                // Draw image to original canvas
                const originalCanvas = document.getElementById("original");
                width = img.width;
                height = img.height;
                originalCanvas.width = width;
                originalCanvas.height = height;
                const originalCtx = originalCanvas.getContext("2d");
                originalCtx.drawImage(img, 0, 0, width, height);

                const imgData = originalCtx.getImageData(0, 0, width, height);

                // Convert to monochrome buffer
                // (colours that are not close to black or white are converted to dither patterns
                // which approximately preserve lightness and correspond to 61 specific colours)
                for (let y = 0; y < height; y++) {
                    const rowPhase = y % 2;
                    const row = monoBuffer[y] = [];
                    const alphaRow = alphaBuffer[y] = [];
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const rImg = imgData.data[idx];
                        const gImg = imgData.data[idx + 1];
                        const bImg = imgData.data[idx + 2];
                        alphaRow[x] = imgData.data[idx + 3] > 127 ? 1 : 0;
                        let result;
                        if (Math.max(rImg, gImg, bImg) < 32) {
                            result = 0;
                        } else if (Math.min(rImg, gImg, bImg) > 224) {
                            result = 1;
                        } else {
                            const color = [rImg, gImg, bImg];
                            const hslImg = rgbToHsl(rImg, gImg, bImg);
                            const phase = x % 3;
                            const phase2 = (x + 1) % 3;
                            const phase3 = (x + 2) % 3;

                            let maxDist = Number.MAX_SAFE_INTEGER;
                            for (const referenceColour of referenceColours) {
                                const testColour = referenceColour.colour;

                                const diff = [
                                    (color[0] - testColour[0]) * 1,
                                    (color[1] - testColour[1]) * 1,
                                    (color[2] - testColour[2]) * 1,
                                    hslImg.l - referenceColour.l,
                                    (hslImg.s - referenceColour.s) * 2,
                                    ((hslImg.h + 360 - referenceColour.h) % 360) * Math.max(0, hslImg.s - 10) / 360
                                ];
                                const dist = diff.reduce((a, v) => a + v * v, 0);

                                if (dist < maxDist) {
                                    maxDist = dist;

                                    if (rowPhase) {
                                        result = [referenceColour.c, referenceColour.m, referenceColour.y][phase];
                                    } else {
                                        result = [referenceColour.r, referenceColour.g, referenceColour.b][phase];
                                    }
                                }
                            }
                        }
                        row[x] = result;
                    }
                }
                renderBw();
                renderArtifactColors();
            };
            img.src = URL.createObjectURL(file);
        }

        function rgbToHsl(r, g, b) {
            // Convert RGB to the 0-1 range
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s;
            const l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // Achromatic (grey)
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }

            // Convert hue to degrees (0-360) and saturation/lightness to percentages (0-100)
            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function renderBw() {
            const canvas = document.getElementById("bw");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            for (let y = 0; y < height; y++) {
                const row = monoBuffer[y];
                const alphaRow = alphaBuffer[y];
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    data[idx] = 0;
                    data[idx + 1] = row[x] * 255;
                    data[idx + 2] = 0;
                    data[idx + 3] = alphaRow[x] * 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            setCanvasHandlers('bw');
        }

        function renderArtifactColors() {
            const canvas = document.getElementById("artifact");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            for (let y = 0; y < height; y++) {
                const row = monoBuffer[y];
                const alphaRow = alphaBuffer[y];
                for (let x = 0; x < width; x++) {
                    let color = [127, 127, 127];
                    let chromaConfidence = 0;
                    if (x >= 2 && x + 1 < width && row[x - 2] == row[x + 1]) chromaConfidence++;
                    if (x >= 1 && x + 2 < width && row[x - 1] == row[x + 2]) chromaConfidence++;
                    if ((x >= 3 && row[x - 3] == row[x]) ||  (x + 3 < width && row[x + 3] == row[x])) chromaConfidence += 2;
                    //if (x + 3 < width && row[x + 3] == row[x]) chromaConfidence++;
                    chromaConfidence *= .25;
                    //chromaConfidence *= chromaConfidence;

                    
                    if (chromaConfidence > 0) {
                        const phase = x % 3;

                        color[phase] = row[x] * 255;

                        const phase2 = (phase + 1) % 3;
                        const l2 = x - 2;
                        const r2 = x + 1;
                        if (l2 >= 0 && r2 < width) {
                            if (row[l2] && row[r2]) color[phase2] = 255;
                            if (!row[l2] && !row[r2]) color[phase2] = 0;
                        }

                        const phase3 = (phase + 2) % 3;
                        const l3 = x - 1;
                        const r3 = x + 2;
                        if (l3 >= 0 && r3 < width) {
                            if (row[l3] && row[r3]) color[phase3] = 255;
                            if (!row[l3] && !row[r3]) color[phase3] = 0;
                        }
                    }
                    const brightness = (1 - chromaConfidence) * (row[x] * 255);
                    color = [brightness + color[0] * chromaConfidence, brightness + color[1] * chromaConfidence, brightness + color[2] * chromaConfidence];

                    const idx = (y * width + x) * 4;
                    if (y % 2) {
                        data[idx] = (color[1] + color[2]) * .5;
                        data[idx + 1] = (color[0] + color[2]) * .5;
                        data[idx + 2] = (color[0] + color[1]) * .5;
                    } else {
                        data[idx] = color[0];
                        data[idx + 1] = color[1];
                        data[idx + 2] = color[2];
                    }
                    data[idx + 3] = alphaRow[x] * 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);            
            setCanvasHandlers('artifact');
            renderBlur(data);
        }

        function renderBlur(data1) {
            const canvas = document.getElementById("blur");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            // TODO: alpha can be improved by not including transparent pixels in colour average

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const w1 = (y % 2) ? 1 : 1;
                    const w2 = (y % 2) ? 1 : 1;
                    let r = data1[idx] * w1;
                    let g = data1[idx + 1] * w1;
                    let b = data1[idx + 2] * w1;
                    let a = data1[idx + 3] * w1;
                    let t = 1 * w1;

                    if (y > 0) {
                        const idx2 = ((y - 1) * width + x) * 4;
                        r += data1[idx2] * w2 * .5;
                        g += data1[idx2 + 1] * w2 * .5;
                        b += data1[idx2 + 2] * w2 * .5;
                        a += data1[idx2 + 3] * w2 * .5;
                        t += .5 * w2;
                    }
                    if (y - 1 < height) {
                        const idx3 = ((y + 1) * width + x) * 4;
                        r += data1[idx3] * w2 * .5;
                        g += data1[idx3 + 1] * w2 * .5;
                        b += data1[idx3 + 2] * w2 * .5;
                        a += data1[idx3 + 3] * w2 * .5;
                        t += .5 * w2;
                    }
                    
                    r = r / t;
                    g = g / t;
                    b = b / t;
                    a = a / t;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = a;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            setCanvasHandlers('blur');
        }
    </script>
</body>

</html>